import"os";import"path";import{setCredentialFeature as e,CredentialsProviderError as r,parseKnownFiles as o,getProfileName as t}from"./core.min.mjs";import"crypto";import"fs";import{exec as i}from"child_process";import{promisify as s}from"util";import"buffer";import"http2";import"stream";import"http";import"https";import"zlib";import"process";const c=async(o,t,c)=>{const n=t[o];if(!t[o])throw new r(`Profile ${o} could not be found in shared credentials file.`,{logger:c});{const a=n.credential_process;if(void 0===a)throw new r(`Profile ${o} did not contain credential_process.`,{logger:c});{const n=s(i);try{const{stdout:r}=await n(a);let i;try{i=JSON.parse(r.trim())}catch{throw Error(`Profile ${o} credential_process returned invalid JSON.`)}return((r,o,t)=>{if(1!==o.Version)throw Error(`Profile ${r} credential_process did not return Version 1.`);if(void 0===o.AccessKeyId||void 0===o.SecretAccessKey)throw Error(`Profile ${r} credential_process returned invalid credentials.`);if(o.Expiration){const e=new Date;if(new Date(o.Expiration)<e)throw Error(`Profile ${r} credential_process returned expired credentials.`)}let i=o.AccountId;!i&&t?.[r]?.aws_account_id&&(i=t[r].aws_account_id);const s={accessKeyId:o.AccessKeyId,secretAccessKey:o.SecretAccessKey,...o.SessionToken&&{sessionToken:o.SessionToken},...o.Expiration&&{expiration:new Date(o.Expiration)},...o.CredentialScope&&{credentialScope:o.CredentialScope},...i&&{accountId:i}};return e(s,"CREDENTIALS_PROCESS","w"),s})(o,i,t)}catch(e){throw new r(e.message,{logger:c})}}}},n=(e={})=>async({callerClientConfig:r}={})=>{e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");const i=await o(e);return c(t({profile:e.profile??r?.profile}),i,e.logger)};export{n as fromProcess};
//# sourceMappingURL=index.min3.mjs.map
